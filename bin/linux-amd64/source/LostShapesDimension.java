/* autogenerated by Processing revision 1286 on 2022-11-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import org.gamecontrolplus.gui.*;
import org.gamecontrolplus.*;
import net.java.games.input.*;
import processing.sound.*;
import beads.*;
import java.util.Arrays;
import java.util.Map;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class LostShapesDimension extends PApplet {

// CONTROLLER LIBRARIES




Utils utils = new Utils();

// SOUND LIBRARY

SoundFile rotationClap;
SoundFile scaleClap;
SoundFile selectionClap;
SoundFile ambiantSound;

// BEADS LIBRARY FOR DISTANCE SOUND

 
AudioContext ac;

// GRAPHICS RELATED VARIABLES
int fpsFontSize = 20;

// GAME INSTANCES
Game game;

// CONTROLLER
ControlDevice controller;


 public void setup() {
    // GRAPHICS SETUP
    // size(800, 800);
    surface.setTitle("Lost Shapes Dimension");
    /* size commented out by preprocessor */;
    noFill();
    textSize(fpsFontSize);


    // CONTROLLER SETUP
    controller = ControlIO.getInstance(this).filter(GCP.STICK).getMatchedDevice("dualsense");
    if (controller == null) {
        println("No suitable device configured");
        // System.exit(-1); // End the program NOW!
    }
    
    // Setup a function to trap events for this button
    controller.getButton("circle").plug(this, "circlePressed", ControlIO.ON_RELEASE);


    // SOUND SETUP
    rotationClap = new SoundFile(this, "rotationClap.wav");
    scaleClap = new SoundFile(this, "scaleClap.wav");
    selectionClap = new SoundFile(this, "selectionClap.wav");
    ambiantSound = new SoundFile(this, "ambiant.wav");


    // GAME INSTANCE
    game = new Game(controller, this);
}


 public void draw() {
    if (! game.getLevels()[game.getCurrentLevel() - 1].hasBeenSetUp()) {
        game.getLevels()[game.getCurrentLevel() - 1].setupLevel();
    }

    if (! game.getLevels()[game.getCurrentLevel() - 1].isComplete()) {
        game.getLevels()[game.getCurrentLevel() - 1].drawLevel();
    }
    else {
        game.levelComplete();
    }
    
    // FPS COUNTER
    blendMode(BLEND);
    // text((int)frameRate, 0, 20);
}


 public void circlePressed() {
    game.getLevels()[game.getCurrentLevel() - 1].circleButtonPressed();
}
class Ellipse extends Layer {
    float radiusY;

    // ELLIPSE
    Ellipse(Map levelParams, float radiusYMultiplier) {
    super(levelParams);
    this.radiusY = this.radius * radiusYMultiplier;
    }

    // CIRCLE
    Ellipse(Map levelParams) {
        super(levelParams);
        this.radiusY = this.radius;
    }

     public void draw() {
        pushMatrix();
        stroke(this.strokeColor);
        translate(this.positionX, this.positionY);
        rotate(radians(this.rotation));
        scale(this.scale);

        for(int i=0; i < this.shapeQuantity; i++) {
            ellipse(0, 0, this.radius + i * this.shapeSpacing, this.radiusY + i * this.shapeSpacing);
        }

        popMatrix();
    }
}
class Game {
    ControlDevice controller;
    LevelsParams levelsParams;
    Map[] levelsParamsList;
    int levelQuantity;
    int currentLevel;
    Level[] levels;
    boolean isFinished;

    // SOUND LIBRARY
    PApplet parentPApplet; // needed for sound library

    Game(ControlDevice controller, PApplet parentPApplet) {
        this.controller = controller;
        this.levelsParams = new LevelsParams();
        this.levelsParamsList = levelsParams.getParamsList();
        println(levelsParamsList);
        this.levelQuantity = levelsParams.getLevelQuantity();
        this.currentLevel = 1;
        this.levels = new Level[levelQuantity];
        this.isFinished = false;
        this.parentPApplet = parentPApplet;
        populateLevels();
    }

    
     public int getLevelQuantity() {
        return levelQuantity;
    }

     public int getCurrentLevel() {
        return currentLevel;
    }

     public void goToNextLevel() {
        this.currentLevel += 1;
    }

    
     public void populateLevels() {
        for (int i = 0; i < levelQuantity; i++) {
            this.levels[i] = new Level(levelsParamsList[i], controller, parentPApplet);
            println(levelsParamsList[i]);
        }
    }

     public Level[] getLevels() {
        return levels;
    }

     public void levelComplete() {
        if (this.currentLevel == this.levelQuantity) {
            this.isFinished = true;
        }

        if (this.isFinished) {
            gameComplete();
        }
        else {
            this.levels[currentLevel].levelComplete();

            int pauseTime = 3000; // ms
            boolean timeElapsed = false;
            int time = millis();

            while (! timeElapsed) {
                if (millis() - time > pauseTime) {
                    timeElapsed = true;
                }
            }

            goToNextLevel();
        }
    }

     public void gameComplete() {
        background(0, 0, 0);
        text("THANKS FOR PLAYING", width / 2, height / 2);
        delay(5000);
        System.exit(-1); // End the program
    }
}
class Layer {
    Map levelParams;
    float positionX;
    float positionY;
    float distanceToOrigin;
    float rotation;
    float rotationToBackground;
    boolean rotationControlEnabled;
    boolean rotationClapPlayed;
    float scale;
    float scaleToBackground; // in percentage of difference
    boolean scaleControlEnabled;
    boolean scaleClapPlayed;
    boolean hasColor;
    int strokeColor;
    int shapeSides;
    int shapeQuantity;
    int shapeSpacing;
    int strokeWeight;
    float radius;
    Params params;

    Layer(Map levelParams) {
        this.levelParams = levelParams;
        this.rotationControlEnabled = (boolean)levelParams.get("rotationControlEnabled");
        this.rotationClapPlayed = false;
        this.scale = 1;
        this.scaleControlEnabled = (boolean)levelParams.get("scaleControlEnabled");
        this.scaleClapPlayed = false;
        this.hasColor = (boolean)levelParams.get("hasColor");
        this.shapeSides = (int)levelParams.get("shapeSides");
        this.shapeQuantity = 100;
        // this.shapeSpacing = 20;
        this.strokeWeight = 8;
        this.radius = width / 60;
        this.params = new Params();
        initRotation();
        initShapeSpacing();
    }

     public void initRotation() {
        if (this.shapeSides > 0) {
                this.rotation = (180 / this.shapeSides);
        }
        else if (this.shapeSides == 0 || this.shapeSides == -1) {
            this.rotation = 0;
        }
    }

     public void initShapeSpacing() {
        switch (this.shapeSides) {
            case -1:
                this.shapeSpacing = 30;
                break;
            case 0:
                this.shapeSpacing = 40;
                break;
            case 3:
                this.shapeSpacing = 35;
                break;
            default:
                this.shapeSpacing = 20;
        }
    }

     public float getPositionX() {
        return positionX;
    }

     public float getPositionY() {
        return positionY;
    }

     public float getDistanceToOrigin() {
        return distanceToOrigin;
    }

     public void computeDistanceToOrigin(float originX, float originY) {
        this.distanceToOrigin = dist(originX, originY, this.positionX, this.positionY);
    } 

     public float getRotation() {
        return rotation;
    }

     public float getRotationToBackground() {
        return rotationToBackground;
    }

     public void computeRotationToBackground(float backgroundRotation) {
        this.rotationToBackground = abs(backgroundRotation - this.rotation);
    }

     public float getScale() {
        return scale;
    }

     public float getScaleToBackground() {
        return scaleToBackground;
    }

     public void computeScaleToBackground(float input) {
        this.scaleToBackground = abs(1 - input / getScale()) * 100;
    }

     public void setStrokeColor(int input) {
        this.strokeColor = input;
    }

     public void init(boolean hasColor) {
        strokeWeight(strokeWeight);

        int[] coordLayer = utils.generateRandomCoord(0, width, 0, height);
        this.positionX = coordLayer[0];
        this.positionY = coordLayer[1];


        if (hasColor) {
            this.strokeColor = utils.generateRandomColor();
        }
        else {
            this.strokeColor = color(0, 0, 0);
        }

        if (this.rotationControlEnabled) {
            if (this.shapeSides > 0) {
                this.rotation = utils.generateRandomRot() % (360 / this.shapeSides);
            }
            else if (this.shapeSides == 0) {
                this.rotation = utils.generateRandomRot() % 180;
            }
            else if (this.shapeSides == -1) {
                println("Not allowed to activate rotation control when playing with circles.");
                System.exit(-1);
            }
        }

        if (this.scaleControlEnabled) {
            this.scale = utils.generateRandomScale();
        }
    }

     public void draw() {

    }

     public void updatePosition(ControlDevice controller) {
        if (abs(controller.getSlider("leftJoyX").getValue()) >= params.getJoystickDeadZone()) {
            this.positionX = ((int)(this.positionX + controller.getSlider("leftJoyX").getValue() * params.getLayerTranslationSpeed()));
        }

        if (abs(controller.getSlider("leftJoyY").getValue()) >= params.getJoystickDeadZone()) {
            this.positionY = ((int)(this.positionY + controller.getSlider("leftJoyY").getValue() * params.getLayerTranslationSpeed()));
        }

        if (this.scaleControlEnabled) {
            if (abs(controller.getSlider("rightJoyY").getValue()) >= params.getJoystickDeadZone()) {
                this.scale = (this.scale - controller.getSlider("rightJoyY").getValue() * params.getLayerScaleSpeed());
            }

            if (controller.getButton("triangle").pressed()) {
                this.scale += 0.002f;
            }

            if (controller.getButton("cross").pressed()) {
                this.scale -= 0.002f;
            }
        }

        if (this.rotationControlEnabled) {
            float l2 = map(controller.getSlider("l2").getValue(), -1, 1, 0, 1);
            float r2 = map(controller.getSlider("r2").getValue(), -1, 1, 0, 1);
            this.rotation += (r2 - l2) * params.getTriggerSpeed();

            if (controller.getButton("r1").pressed()) {
                this.rotation += 0.05f;
            }

            if (controller.getButton("l1").pressed()) {
                this.rotation -= 0.05f;
            }

            if (this.shapeSides > 0) {
                // Nasty formula to map the rotation to only positive value 0 <= x <= (360 / this.shapeSides)
                this.rotation = ((this.rotation % (360 / this.shapeSides)) + (360 / this.shapeSides)) % (360 / this.shapeSides);
            }
            else if (this.shapeSides == 0) {
                this.rotation = ((this.rotation % 180) + 180) % 180;
            }

            
        }

        if (controller.getHat("crosspad").left()) {
            this.positionX -= 0.1f;
        }

        if (controller.getHat("crosspad").right()) {
            this.positionX += 0.1f;
        }

        if (controller.getHat("crosspad").up()) {
            this.positionY -= 0.1f;
        }

        if (controller.getHat("crosspad").down()) {
            this.positionY += 0.1f;
        }
    }
}
class Level {
    Map levelParams;
    int levelID;
    int layerQuantity;
    Layer[] layers;
    int shapeSides;
    boolean hasColor;
    float totalDistanceToOrigin;
    int circleButtonPressedCount;
    int layerToControl;
    float sumOfLayersRotations;
    float sumOfLayersScalesDifferences;
    boolean hasBeenSetUp;
    boolean isComplete;
    ControlDevice controller;
    float radiusYMultiplier;

    // SOUND LIBRARY
    PApplet parentPApplet; // needed for sound library
    Sound master;

    // BEADS LIBRARY
    WavePlayer lfoFreq;
    WavePlayer lfoAmp;
    Function function;
    WavePlayer distanceSoundWave;
    Gain distanceSoundGain;

    Glide carrierFreq;
    Glide modFreqRatio;


    Level(Map levelParams, ControlDevice controller, PApplet parentPApplet) {
        this.levelParams = levelParams;
        this.levelID = (int)levelParams.get("ID");
        this.layerQuantity = (int)levelParams.get("layerQuantity");
        this.layers = new Layer[layerQuantity + 1]; // +1 because layers[0] = background
        this.shapeSides = (int)levelParams.get("shapeSides");
        this.hasColor = (boolean)levelParams.get("hasColor");
        this.circleButtonPressedCount = 0;
        this.layerToControl = 1;
        this.hasBeenSetUp = false;
        this.isComplete = false;
        this.controller = controller;
        this.parentPApplet = parentPApplet;
        this.master = new Sound(this.parentPApplet);
        initRadiusYMultiplier();
        instanciateLayers();
    }

     public void initRadiusYMultiplier() {
        this.radiusYMultiplier = random(20);
    }

     public void instanciateLayers() {
        for (int i = 0; i <= layerQuantity; i++) {
            if (this.shapeSides > 0) {
                // POLYGON
                this.layers[i] = new Polygon(levelParams);
            }
            else if (this.shapeSides == 0) {
                // ELLIPSE
                this.layers[i] = new Ellipse(levelParams, radiusYMultiplier);
            }
            else if (this.shapeSides == -1) {
                // CIRCLE
                this.layers[i] = new Ellipse(levelParams);
            }
            else {
                println("Please input a valid number of sides for your shapes in the LevelsParams.");
                System.exit(-1);
            }
        }
    }

     public void initBeads() {
        // ac = AudioContext.getDefaultContext();
        // this.lfoFreq = new WavePlayer(1, Buffer.SINE);
        // this.lfoAmp = new WavePlayer(0.1, Buffer.SINE);

        // this.function = new Function(lfoFreq) {
        //     float calculate() {
        //         return x[0] * 50.0 + 200.0;
        //     }
        // };

        // this.distanceSoundWave = new WavePlayer(function, Buffer.SINE);
        // this.distanceSoundGain = new Gain(1, this.lfoAmp);
        // this.distanceSoundGain.addInput(this.distanceSoundWave);
        // ac.out.addInput(this.distanceSoundGain);
        // ac.start();


        ac = AudioContext.getDefaultContext();
        this.carrierFreq = new Glide(5);
        this.modFreqRatio = new Glide(1);
        Function modFreq = new Function(carrierFreq, modFreqRatio) {
            public float calculate() {
            return x[0] * x[1];
            }
        };
        WavePlayer freqModulator = new WavePlayer(modFreq, Buffer.SINE);
        Function carrierMod = new Function(freqModulator, carrierFreq) {
            public float calculate() {
            return x[0] * 400.0f + x[1];    
            }
        };
        this.distanceSoundWave = new WavePlayer(carrierMod, Buffer.SINE);
        this.distanceSoundGain = new Gain(1, 0.2f);
        this.distanceSoundGain.addInput(this.distanceSoundWave);
        ac.out.addInput(this.distanceSoundGain);
        ac.start();

    }

     public boolean isComplete() {
        return isComplete;
    }

     public void circleButtonPressed() {
        this.circleButtonPressedCount += 1;
        updateLayerToControl();
        if (hasColor && layerQuantity > 1) {
            this.layers[getLayerToControl() - 1].setStrokeColor(utils.generateRandomColor());
            selectionClap.play();
        }
    }

     public int getLayerToControl() {
        return layerToControl;
    }

     public void updateLayerToControl() {
        this.layerToControl = (circleButtonPressedCount % layerQuantity) + 1;
    }

     public boolean hasBeenSetUp() {
        return hasBeenSetUp;
    }

     public void setupLevel() {
        println("--------");
        println("LEVEL", game.getCurrentLevel());

        // BACKGROUND STATIC LAYER
        layers[0].init(false);
        
        // DYNAMIC LAYERS
        for (int i = 1; i <= layerQuantity; i++) {
            layers[i].init(this.hasColor);
        }

        // SOUND SETUP
        master.volume(0.3f);
        ambiantSound.loop();

        // DISTANCE SOUND INIT
        initBeads();

        this.hasBeenSetUp = true;
    }

     public boolean checkIfComplete() {
        if ((totalDistanceToOrigin < layerQuantity) &&
            (sumOfLayersRotations < layerQuantity) &&
            (sumOfLayersScalesDifferences < ((float)layerQuantity / 10))
        ) {
            return true;
        }
        else {
            return false;
        }
    }

     public void drawLevel() {
        this.totalDistanceToOrigin = 0;
        this.sumOfLayersRotations = 0;
        this.sumOfLayersScalesDifferences = 0;

        background(100, 100, 100);
        rectMode(CENTER);

        // STATIC BACKGROUND LAYER
        blendMode(BLEND);
        this.layers[0].draw();

        // DYNAMIC LAYERS
        if (this.hasColor) {
            blendMode(DIFFERENCE);
        }
        else {
            blendMode(BLEND);
        }

        for(int i=1; i <= this.layerQuantity; i++) {
            if (this.layerToControl == i) {
                layers[i].updatePosition(controller);
            }

            this.layers[i].draw();

            layers[i].computeDistanceToOrigin(layers[0].getPositionX(), layers[0].getPositionY());
            layers[i].computeRotationToBackground(layers[0].getRotation());
            layers[i].computeScaleToBackground(layers[0].getScale());
            

            // ROTATION CLAP SOUND
            if ((layers[i].getRotationToBackground() < 1) && (! layers[i].rotationClapPlayed)) {
                rotationClap.play();
                layers[i].rotationClapPlayed = true;
            }
            if (layers[i].getRotationToBackground() > 1) {
                layers[i].rotationClapPlayed = false;
            }

            // SCALE CLAP SOUND
            if ((layers[i].getScaleToBackground() < 0.1f) && (! layers[i].scaleClapPlayed)) {
                scaleClap.play();
                layers[i].scaleClapPlayed = true;
            }
            if (layers[i].getScaleToBackground() > 0.1f) {
                layers[i].scaleClapPlayed = false;
            }


            this.totalDistanceToOrigin += layers[i].getDistanceToOrigin();
            this.sumOfLayersRotations += layers[i].getRotationToBackground();
            this.sumOfLayersScalesDifferences += (layers[i].getScaleToBackground());
        }

        // CONTINUOUS SOUND RELATED TO SHAPES DISTANCES TO ORIGIN
        // BEADS LIBRARY
        // this.lfoFreq.setFrequency(map(this.totalDistanceToOrigin, 0, width * this.layerQuantity, 0.05, 3));
        // this.lfoAmp.setFrequency(map(this.totalDistanceToOrigin, 0, width * this.layerQuantity, 0.06, 3));

        this.modFreqRatio.setValue(map(this.totalDistanceToOrigin, 0, width * this.layerQuantity, 0.1f, 20));

        this.isComplete = checkIfComplete();
    }

     public void levelComplete() {
        // BEADS LIBRARY
        ac.out.clearInputConnections();

        // SOUND LIBRARY
        ambiantSound.stop();

        background(0, 0, 0);
        text("LEVEL COMPLETE", width / 2, height / 2);
        println("Level", game.getCurrentLevel(), "complete");
    }
}


class LevelsParams{
    int levelQuantity;
    Map level1Params;
    Map level2Params;
    Map level3Params;
    Map level4Params;
    Map level5Params;
    Map level6Params;
    Map level7Params;
    Map level8Params;
    Map level9Params;
    Map level10Params;
    Map level11Params;
    Map level12Params;
    Map level13Params;
    Map level14Params;
    Map[] paramsList;

    LevelsParams() {
        this.levelQuantity = 14;

        // 1 CIRCLE, NO COLOR
        this.level1Params = Map.of(
            "ID", 1,
            "layerQuantity", 1,
            "shapeSides", -1,
            "hasColor", false,
            "rotationControlEnabled", false,
            "scaleControlEnabled", false
        );

        // 1 CIRCLE, COLORS
        this.level2Params = Map.of(
            "ID", 2,
            "layerQuantity", 1,
            "shapeSides", -1,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", false
        );

        // 2 CIRCLES, COLORS
        this.level3Params = Map.of(
            "ID", 3,
            "layerQuantity", 2,
            "shapeSides", -1,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", false
        );

        // 1 SQUARE, COLORS
        this.level4Params = Map.of(
            "ID", 4,
            "layerQuantity", 1,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", false
        );

        // 2 SQUARES, COLORS
        this.level5Params = Map.of(
            "ID", 5,
            "layerQuantity", 2,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", false
        );

        // 1 SQUARE, COLOR, ROTATION
        this.level6Params = Map.of(
            "ID", 6,
            "layerQuantity", 1,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", false
        );

        // 1 TRIANGLE, COLOR, ROTATION
        this.level7Params = Map.of(
            "ID", 7,
            "layerQuantity", 1,
            "shapeSides", 3,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", false
        );

        // 2 TRIANGLES, COLOR, ROTATION
        this.level8Params = Map.of(
            "ID", 8,
            "layerQuantity", 2,
            "shapeSides", 3,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", false
        );

        // 2 SQUARES, COLOR, ROTATION
        this.level9Params = Map.of(
            "ID", 9,
            "layerQuantity", 2,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", false
        );

        // 1 CIRCLE, COLOR, SCALE
        this.level10Params = Map.of(
            "ID", 10,
            "layerQuantity", 1,
            "shapeSides", -1,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", true
        );

        
        // 1 SQUARE, COLOR, ROTATION, SCALE
        this.level11Params = Map.of(
            "ID", 11,
            "layerQuantity", 1,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", true
        );

        // 2 CIRCLES, COLOR, SCALE
        this.level12Params = Map.of(
            "ID", 12,
            "layerQuantity", 2,
            "shapeSides", -1,
            "hasColor", true,
            "rotationControlEnabled", false,
            "scaleControlEnabled", true
        );

        // 2 SQUARES, COLOR, ROTATION, SCALE
        this.level13Params = Map.of(
            "ID", 13,
            "layerQuantity", 2,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", true
        );

        // 3 SQUARES, COLOR, ROTATION, SCALE
        this.level14Params = Map.of(
            "ID", 14,
            "layerQuantity", 3,
            "shapeSides", 4,
            "hasColor", true,
            "rotationControlEnabled", true,
            "scaleControlEnabled", true
        );            

        populateParamsList();
    }

     public int getLevelQuantity() {
        return levelQuantity;
    }

     public void populateParamsList() {
        this.paramsList = new Map[levelQuantity];
        this.paramsList[0] = level1Params;
        this.paramsList[1] = level2Params;
        this.paramsList[2] = level3Params;
        this.paramsList[3] = level4Params;
        this.paramsList[4] = level5Params;
        this.paramsList[5] = level6Params;
        this.paramsList[6] = level7Params;
        this.paramsList[7] = level8Params;
        this.paramsList[8] = level9Params;
        this.paramsList[9] = level10Params;
        this.paramsList[10] = level11Params;
        this.paramsList[11] = level12Params;
        this.paramsList[12] = level13Params;
        this.paramsList[13] = level14Params;
    }

     public Map[] getParamsList() {
        return paramsList;
    }

     public Map getLevel1Params() {
        return level1Params;
    }
}
class Params {
    float joystickDeadZone;
    float layerTranslationSpeed;
    float layerScaleSpeed;
    float triggerSpeed;

    Params() {
        this.joystickDeadZone = 0.05f;
        this.layerTranslationSpeed = 7.0f;
        this.layerScaleSpeed = 0.5f;
        this.triggerSpeed = 2.0f;
    }

     public float getJoystickDeadZone() {
        return joystickDeadZone;
    }

     public float getLayerTranslationSpeed() {
        return layerTranslationSpeed;
    }

     public float getLayerScaleSpeed() {
        return layerScaleSpeed;
    }

     public float getTriggerSpeed() {
        return triggerSpeed;
    }
}
class Polygon extends Layer {

    Polygon(Map levelParams) {
        super(levelParams);
    }

     public void draw() {
        pushMatrix();
        stroke(this.strokeColor);
        translate(this.positionX, this.positionY);
        rotate(radians(this.rotation));
        scale(this.scale);

        for(int i=0; i < this.shapeQuantity; i++) {
            drawPoly(this.radius + i * this.shapeSpacing);
        }

        popMatrix();
    }

     public void drawPoly(float radius) {
        float angle = TWO_PI / this.shapeSides;
        beginShape();
        for(float a = 0; a < TWO_PI; a += angle) {
            float sx = radius * cos(a);
            float sy = radius * sin(a);
            vertex(sx, sy);
        }
        endShape(CLOSE);
    }
}

class Utils {
     public int generateRandomColor() {
        return color(random(256), random(256), random(256));
    }

     public int[] generateRandomCoord(int minX, int maxX, int minY, int maxY) {
        return new int[] {(int)random(minX, maxX), (int)random(minY, maxY)};
    }

     public float generateRandomRot() {
        return random(0, 361);
    }

     public float generateRandomScale() {
        return random(1, 3);
    }
}


  public void settings() { fullScreen(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "LostShapesDimension" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
